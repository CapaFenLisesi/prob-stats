# Continuous Random Variables

So far, we have only considered discrete random variables, i.e.,
variables taking only integer values.  But what if we want to use
random variables to represent lengths or volumes or distances or
masses or concentrations or any of the other continuous properties in
the physical world?  We will need to generalize our approach so far.

Continuous random variables take on real values.  The set of real
numbers is *uncountable* in the sense of being strictly larger than
the set of integers.^[Georg Cantor developed the technique of
diagonalization to show it was impossible to have a one-to-one map
from the reals to the integers, thus proving the set of reals is
uncountable.]

The mathematics of probability is the same for real values.  Even more
importantly from a practical standpoint, the way we calculate event
probabilities and estimates remains the same with continuous
quantities.  The notion of a probability mass function, on the other
hand, must be replaced by its continuous equivalent, the probability
density function.


## Spinners and uniform continuous variables

Suppose $\Theta$ is a random variable representing the angle at which
a fair spin of a spinner lands.  We will use degrees and thus suppose
the value of $\Theta$ is between 0 and 360^[The end points are the
same, representing a complete rotation of 360 degrees; they are
labeled as such in the plot.]

```{r fig.cap = "A spinner resting at 36 degrees, or 10% of the way around the circle.  A fair spin might land anywhere between 0 and 360 degrees."}

df_spinner <- data.frame(value = c("0-360 degrees"), prob = c(0.3))
plot_spinner <-
  ggplot(data = df_spinner,
         aes(x = factor(1), y = prob, fill = value)) +
  geom_bar(stat = "identity", position = "fill", fill = "#ffffe8",
           color="black", size = 0.25) +
  coord_polar(theta = "y") +
  geom_segment(aes(y =  0.1, yend =  0.1, x = -1, xend = 1.375),
               arrow = arrow(type = "open"),
	       size = 0.5, color = "#666666") +
  geom_point(aes(x = -1, y = 0), color = "#666666", size = 3) +
  scale_x_discrete(breaks = c()) +
  scale_y_continuous(breaks = c(0, 0.1, 0.25, 0.5, 0.75),
                     labels = c("360 | 0    ", "36", "90", "180", "270")) +
  xlab(expression(paste(theta, " degrees"))) +
  ylab("") +
  ggtheme_tufte() +
  theme(legend.position = "none")
plot_spinner
```

What does fair mean for continuous probabilities?  At the least, we
should be able to say that the probality of landing in any
band is the same no matter where the band lies on the circle.  That
is, landing between 0 and 36 degrees should be the same as landing
between 200 and 236 degrees.  Also, because 36 degrees is one tenth of
the way around the circle, the chance of landing in any 36 degree band
has to be 10%.^[This is because the circle can be divided into ten
bands to create exhaustive and exclusive intervals, the event
probabilities of landing in which must be the same by fairness and
must total one because they exhaust all possible outcomes.] We can
express that in probability notation as

$$
\mbox{Pr}[0 \leq \Theta \leq 36]
\ = \
\frac{1}{10}
$$

and

$$
\mbox{Pr}[200 \leq \Theta \leq 236]
\ = \
\frac{1}{10}.
$$

We are not talking about the probability of $\Theta$ taking on a
particular value, but rather of it falling in a particular interval.^[
In general, the probability of a fair spinner $\Theta$ falling in
interval is the fraction of the circle represented by the interval, i.e.,
$$
\mbox{Pr}[\theta_1 \leq \Theta \leq \theta_2]
= \frac{\theta_2 - \theta_1}{360}.
$$
for $0 \leq \theta_1 \leq \theta_2 \leq 360.$
]
For continuous random variables, outcomes do not have probability
mass.  Instead, probability mass is assigned continuously based on the
probability of a variable falling in a region.

## The paradox of vanishing point probabilities

In our first example, we took a fair spinner to land at exactly 36
degrees; it could've been 36.0376531 degrees or even an irrational
number such as $0.3333\cdots.$^[When I learned decimal
representations, we wrote $0.\bar{3}$ for the decimal
representation of $\frac{1}{3}.$] What's the probability the spinner
landed on exactly 36 degrees? Paradoxically, the answer is zero.

$$
\mbox{Pr}[\Theta = 36] = 0.
$$

Why must this be?  If the probability of any specific outcome was
greater than zero, every other possible value would have to have the
same probability to satisfy fairness.  But then if we summed them all
up, the total would be greater than one, which is not possible.
Something has to give, and that something is the idea of particular
point outcomes having probability mass in a continuous distribution.
The paradox arises because some number must come up, but every number
has zero probability.

## Simulating uniform values

We will assume that our programming language comes equipped with a
function `uniform_rng(L, H)` that generates numbers uniformly in the
interval $[L, H]$.

For instance, the following program simulates from the uniform
interval.


```
for (m in 1:M)
  y[m] = uniform_rng(0, 1)
print 'y = ' y
```
Let's simulate $M = 10$ draws and look at the result,

```{r}
set.seed(1234)
M <- 10
y = runif(M)
for (m in 1:M)
  printf('%5.4f ', y[m])
```

These are only printed to a few decimal places.  As usual, it's hard
to get a sense for the sequence of values as raw numbers.  The most
popular way to summarize one-dimensional data is with a *histogram*,
as shown in the following plot.

```{r fig.cap="Histogram of 10 draws from a $\\mbox{uniform}(0, 1)$ distribution."}
df_unif_10 <- data.frame(y = y)
unif_10_plot <-
  ggplot(df_unif_10, aes(y)) +
  geom_histogram(binwidth = 0.1, center = 0.05,
                 color = "black", fill="#ffffe6", size = 0.25) +
  scale_x_continuous("y", breaks = seq(0, 1, 0.1),
                    limits = c(0, 1), expand = c(0, 0.02)) +
  scale_y_continuous("count", breaks = c(1, 2, 3, 4, 5),
                     expand = c(0.02, 0)) +
  ggtheme_tufte()
unif_10_plot
```

The range of values from 0 to 1 is broken up into ten equally spaced
bins, 0 to 0.1, 0.1 to 0.2, up to 0.9 to 1.0. Each bin is then drawn
as a rectangle with a height proportional to the number of values that
fell into the bin.

Even though the distribution draws uniformly in the interval, with
only ten draws, the probability of having one draw in each bin is
small,^[The first draw can be in any bin, the second in any of 9 bins,
the third in any of 8 bins, and so on, yielding a probability for each
bin containing a single draw of $$\prod_{n=1}^{10} \frac{n}{10}
\approx 0.00036.$$] whereas the probability of having many values in a
single bin is relatively high.^[For example, the probability of having
a bin with exactly five draws involves a choice of the distinguished
bin, a choice of which of the five draws go in the distinguished
bin, then the probabilities of the distinguished bins and other bins,
$${10 \choose 1} \times {10 \choose 5} \times \left(\frac{1}{10}\right)^5 \times
\left(\frac{9}{10}\right)^5 \approx 0.015.$$]  As usual, we turn to
repetition and sizing to see what's going on.

```{r}
set.seed(1234)
df_runif <- data.frame()
for (N in 2^c(2, 4, 6, 8, 10, 12))
  df_runif <- rbind(df_runif,
                    data.frame(y = runif(N),
                               size = rep(N, N)))
```

```{r fig.asp = 1.25, fig.cap="Histograms for uniform(0, 1) samples of increasing sizes.  The proportion of draws falling into each bin becomes more uniform as the sample size increases.  With each sample plotted to the same height, the vertical count axis varies in scale among the plots."}

plot_runif <-
  ggplot(df_runif, aes(y)) +
  facet_grid(size ~ ., scales = "free") +
  geom_histogram(binwidth = 0.1, center = 0.05, color = "black",
                 fill="#ffffe6", size = 0.25) +
  scale_x_continuous("y", breaks = seq(0, 1, 0.2), limits = c(0, 1),
                     expand = c(0, 0.02)) +
  scale_y_continuous("proportion of draws", breaks = c(),
                     expand = c(0.02, 0)) +
  coord_fixed(ratio = 0.5) +
  theme(panel.spacing.y = unit(24, "pt")) +
  ggtheme_tufte()
plot_runif
```

## Calculating $\pi$ via simulation

Now that we have a continuous random number generator, there are all
kinds of values we can compute. Here, we show how to calculuate the
first few digits of $\pi$. We'll carry this out by formulating an
event probability over some continuous random variables whose
probability is a fraction of $\pi$.

We start with the basic fact of algebra that that $\pi$ is the area of
a unit radius circle.^[The area of a circle of radius $r$ is $\pi
\times r^2$, so when $r = 1$, the area is $\pi$.] We then assume there
are two independent, uniform random variables $X$ and $Y$,

$$
X, Y \sim \mbox{uniform}(-1, 1).
$$

Simulations $x^{(m)}, y^{(m)}$ of these variables pick out a point on
the plane within a square bounded by -1 and 1 in both dimensions. Here
is a plot of the square in which the draws will fall. Also shown is a
circle of unit radius inscribed within that square.  Draws may or may
not fall within the circle.[Technically, the
bearer of area is a disc and the line around its border a circle.
Mathematicians are picky because, topologically speaking, a disc has
two dimensions whereas a circle has but one.]

```{r fig.cap="A unit circle (dotted line) centered at the origin is inscribed in a square (dashed lines) with axes running from -1 to 1."}

bullseye_target_plot <-
  ggplot(data.frame(x = c(), y = c()), aes(X, Y), xlim = c(-1, 1), ylim = c(-1, 1)) +
#  geom_vline(xintercept = 0, size = 0.3, color = "#333333") +
#  geom_hline(yintercept = 0, size = 0.3, color = "#333333") +
  annotate("path", x = cos(radians), y = sin(radians),
           size = 0.8, color = '#333333', linetype="dotted") +
  annotate("path", x = c(-1, -1, 1, 1, -1), y = c(-1, 1, 1, -1, -1),
           size = 0.4, color = '#333333', linetype="dashed") +
  scale_x_continuous(limits = c(-1, 1), breaks = c(-1, 0, 1)) +
  scale_y_continuous(limits = c(-1, 1), breaks = c(-1, 0, 1)) +
  coord_fixed(ratio = 1) +
  ggtheme_tufte()
bullseye_target_plot
```

A point $(x, y)$ will fall within the unit circle if^[A point falls on
a circle of radius $r$ if $x^2 + y^2 = r^2$.]

$$
x^2 + y^2 \leq 1.
$$

Let's see what this looks like with $M = 250$ draws.  The resulting
plot is known as a *scatterplot*---it places values at their $(x, y)$
coordinates, resulting in them being "scattered."

```{r out.width="80%", fig.cap='$M = 250$ simulated draws of $(x^{(m)}, y^{(m)})$ from a $\\mbox{uniform}(-1, 1)$ distribution.  Points within the circle are plotted using $+$ and those outside it with $\\circ$.'}

set.seed(1234)
M <- 250
X <- runif(M, -1, 1)
Y <- runif(M, -1, 1)
df <- data.frame(X = X, Y = Y, within = (X^2 + Y^2 < 1))
radians <- seq(0, 2 * pi, length.out=200)
df <- data.frame(X = X, Y = Y, within = (X^2 + Y^2 < 1))
bullseye_plot <-
  ggplot(df, aes(X, Y), xlim = c(-1, 1), ylim = c(-1, 1)) +
#  geom_vline(xintercept = 0, size = 0.3, color = "#333333") +
#  geom_hline(yintercept = 0, size = 0.3, color = "#333333") +
  annotate("path", x = cos(radians), y = sin(radians),
           size = 0.8, color = '#333333', linetype="dotted") +
  annotate("path", x = c(-1, -1, 1, 1, -1), y = c(-1, 1, 1, -1, -1),
           size = 0.4, color = '#333333', linetype="dashed") +
  geom_point(aes(shape = within, color = within), size = 1.25) +
  scale_shape_manual(values = c(1, 3)) +
  scale_color_manual(values = c("#333333", "#111111")) +
  scale_x_continuous(limits = c(-1, 1), breaks = c(-1, 0, 1)) +
  scale_y_continuous(limits = c(-1, 1), breaks = c(-1, 0, 1)) +
  coord_fixed(ratio = 1) +
  ggtheme_tufte() +
  theme(legend.position = "none")
bullseye_plot
```

For random variables $X, Y \sim \mbox{uniform}(-1, 1)$, the event of
their falling within the unit circle is $X^2 + Y^2 \leq 1$. Because
$X$ and $Y$ are drawn uniformly from within the square, the
probability of their being within the circle is proportional to the
circle's area. The circle's area is $\pi$, whereas the overall area of
the square is 4. So the probability of a random draw within the square
being within the circle is

$$
\mbox{Pr}[X^2 + Y^2 \leq 1] = \frac{\pi}{4}.
$$

We know how to estimate event probabilities using simulation.  The
code here is straightforward.

```
for (m in 1:M)
  x[m] = uniform_rng(-1, 1)
  y[m] = uniform_rng(-1, 1)
  inside[m] = (x[m]^2 + y[m]^2 <= 1)
print 'Pr[in circle] = ' sum(inside) / M
print 'esimtated pi = ' 4 * sum(inside) / M
```

We recover the simulation-based estimate of $\pi$ by multiplying the
event probability of $X^2 + Y^2 \leq 1$ by four.

Let's run this with $M = 1\,000\,000$ and see what we get,

```{r}
set.seed(1234)
M <- 1e6
X <- runif(M, -1, 1)
Y <- runif(M, -1, 1)
Pr_target <- (1 / M) * sum(X^2 + Y^2 < 1)
printf('Pr[in circle] = %4.3f', Pr_target)
printf('estimated pi = %4.3f', 4 * Pr_target)
```

We actually knew the answer ahead of time here, $\pi \approx 3.14159$.
The simulation-based estimate is on the right track.^[But not going to
win any $\pi$ digit-generating contests, either. Remember, we need one
hundred *times* as many draws for each subsequent digit of precision
using i.i.d. simulation.] At least the first couple of digits are
correct.

If you want to do this all the old-fashioned way with calculus, note
that the top half of the circle is given by the function $y = \sqrt{1
- x^2}$.  Integrating this from $-1$ to $1$ and doubling it thus
produces the required value,

$$
\pi = 2 \times \int_{-1}^1 \sqrt{1 - x^2} \, \mathrm{d}x.
$$

Simulation-based methods are largely used in practice to solve nasty
integrals without analytic solutions.
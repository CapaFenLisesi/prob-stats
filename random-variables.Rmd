# Random Variables and Event Probabilities

## Random variables

Let $Y$ be the result of a fair coin flip.  Not a general coin flip,
but a specific instance of flipping a specific coin at a specific
time.  Defined this way, $Y$ is what's known as a *random variable*,
meaning a variable that takes on different values with different
probabilities.^[Random variables are conventionally written using
upper-case letters to distinguish them from ordinary mathematical
variables which are bound to single values and conventionally written
using lower-case letters.]

Probabilities are scaled between 0% and 100% as in natural language.
If a coin flip is fair, there is a 50% chance the coin lands face up
("heads") and a 50% chance it lands face down ("tails").  For
concreteness and ease of analysis, random variables will be restricted
to numerical values.  For the specific coin flip in question, the
random variable $Y$ will take on the value 1 if the coin lands heads
and the value 0 if it lands tails.


## Events and probability

An outcome such as the coin landing heads is called an *event* in
probability theory.  For our purposes, events will be defined as
conditions on random variables.  For example, $Y = 1$ denotes the
event in which our coin flip lands heads. The functional $\mbox{Pr}[\,
\cdot \,]$ defines the probability of an event.  For example, for our
fair coin toss, the probability of the event of the coin landing heads
is written as

$$
\mbox{Pr}[Y = 1] = 0.5.
$$

In order for the flip to be fair, we must have $\mbox{Pr}[Y = 0] =
0.5$, too.  The two events $Y = 1$ and $Y = 0$ are mutually exclusive
in the sense that both of them cannot occur at the same time.  In
probabilistic notation,

$$
\mbox{Pr}[Y = 1 \ \mbox{and} \ Y = 0] = 0.
$$

The events $Y = 1$ and $Y = 0$ are also exhaustive, in the sense that
at least one of them must occur.  In probabilistic notation,

$$
\mbox{Pr}[Y = 1 \ \mbox{or} \ Y = 0] = 1.
$$

In these cases, events can be conjoined (with "and") or disjoined
(with "or");  they can also be negated.  For example,

$$
\mbox{Pr}[Y \neq 1] = 0.5.
$$


## Sample spaces and possible worlds

Even though the coin flip will have a specific outcome in the real
world, we consider alternative ways the world could have been.  Thus
even if the coin lands heads ($Y = 1$), we entertain the possibility
that it could've landed tails ($Y = 0$).  Such counterfactual
reasoning is the key to understanding probability theory and applied
statistical inference.

An alternative way the world could be, that is, a *possible world*,
will determine the value of every random variable. The collection of
all such possible worlds is called the *sample space*.^[The sample
space conventionally written as $\Omega$, the capitalized form of the
last letter in the Greek alphabet.]  The sample space may be
conceptualized as an urn containing a ball for each possible way the
world can be.  On each ball is written the value of every random
variable.^[Formally, a random variable $X$ can be represented as a
function from the sample space to a real value, i.e., $X:\Omega
\rightarrow \mathbb{R}$. For each possible world $\omega \in \Omega$,
the variable $X$ takes on a specific value $X(\omega) \in
\mathbb{R}$.]

Now consider the event $Y = 0$, in which our coin flip lands tails. In
some worlds, the event occurs (i.e., $0$ is the value recorded for
$Y$) and in others it doesn't.  An event picks out the subset of
worlds in which it occurs.^[Formally, an event is defined by a subset
of the sample space, $E \subseteq \Omega$.]


## Simulating random variables

We are now going to turn our attention to computation, and in
particular, simulation, with which we will use to estimate event
probabilities.

The primitive unit of simulation is a function that acts like a random
number generator.  But we only have computers to work with and they
are deterministic.  At best, we can created so-called *pseudorandom
number generators*.  Pseudorandom number generators, if they are well
coded, produce deterministic streams of output that appear to be
random.^[There is a large literature on pseudorandom number generators
and tests for measurable differences from truly random streams.]
  
For the time being, we will assume we have a primitive pseudorandom
number generator `uniform_01_rng()`, which behaves roughly like it has
a 50% chance of returning 1 and a 50% chance of returning 0.^[The name
arises because random variables in which every possible outcome is
equally likely are said to be *uniform*.]  That is, our pseudorandom
number generator behaves as if

$$
\mathtt{uniform\_01\_rng}()
=
\begin{cases}
0 & \mathrm{with \ a} \ 50\% \ \mathrm{chance}
\\
1 & \mathrm{with \ a} \ 50\% \ \mathrm{chance}
\end{cases}
$$

Suppose we want to simulate our random variable $Y$.  We can do so by
calling `uniform_01_rng` and noting the answer.

Throughout this book, we will provide computer programs in the form of
pseudocode, which is not a particular programming language, but should
be precise enough to be coded in a concrete programming language of
the reader's choice.^[The actual programs for this book are coded in R
and available from the source repository for this book.]

A simple program to generate a realization of a random coin flip,
assign it to an integer variable `y`, and print the result could be
coded as follows.

```
int y = uniform_01_rng()
print 'y = ' y
```

The variable `y` is declared to be an integer and assigned to the
result of calling the `uniform_01_rng()` function.^[The use of a
lower-case $y$ was not accidental.  The variable $y$ represents an
integer, which is the type of a realization of a random $Y$
representing the outcome of a coin flip.  In code, variables are
written in typewriter font (e.g., `y`), whereas in text they are
written in italics like other mathematical variables (e.g., $y$).]
The print statement outputs the quoted string `y = ` &nbsp; followed
by the value of the variable `y`.  Executing the program might produce
the following output.

```{r}
printf("y = %d", rbinom(1, 1, 0.5))
```

If we run it a nine more times, it might print

```{r}
printf("y = %d", rbinom(1, 1, 0.5))
printf("y = %d", rbinom(1, 1, 0.5))
printf("y = %d", rbinom(1, 1, 0.5))
printf("y = %d", rbinom(1, 1, 0.5))
printf("y = %d", rbinom(1, 1, 0.5))
printf("y = %d", rbinom(1, 1, 0.5))
printf("y = %d", rbinom(1, 1, 0.5))
printf("y = %d", rbinom(1, 1, 0.5))
printf("y = %d", rbinom(1, 1, 0.5))
```
When we say it might print these things, we mean the results will
depend on the pseudorandom number generator `uniform_01_rng()`.  

## Seeding a simulation

Simulations can be made exactly reproducible by setting what is known
as the *seed* of a pseudorandom number generator.  This seed
establishes the deterministic sequence of results that the
pseudorandom number generator produces.  For instance, contrast the program

```
seed_rng(1234)
for (n in 1:10) print uniform_01_rng()
for (n in 1:10) print uniform_01_rng()
```

which produces the output

```{r}
set.seed(1234)
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
```

with the program

```
seed_rng(1234)
for (n in 1:10) print uniform_01_rng()
seed_rng(1234)
for (n in 1:10) print uniform_01_rng()
```

which produces

```{r}
set.seed(1234)
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
set.seed(1234)
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
```

Resetting the seed in the second case causes exactly the same ten
pseudorandom numbers to be generated a second time.


Now when we run twice, we get the same sequence of draws
from the pseudorandom number generators.



Every well-written simulation should allow the seed to be set
manually.


## Seeding random number generators.



*Simulation and random variables.* The program could be expanded with
a loop to write ten outputs.

```
repeat 10 times:
  print uniform_01_rng() ' '
```

Such a program might produce the following output.

```{r}
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
```

Such a program might represent either

1. ten different simulations of the same random variable $Y$, say
$y^{(1)}, \ldots, y^{(10)}$, with parenthetical superscripts indexing
the simulation, or

1.  a single simulation of ten different random variables,
$Y_1, \ldots, Y_{10}$, say $y_1, \ldots, y_{10}$.

The first situation corresponds to simulating ten different ways the
world might be, whereas the second corresponds to simulating a single
way the world might be.  Multiple simulations of the way the world
might be form the building block of computational statistical
inference, and will be the focus of much of this book.

Running the program five times, we get the following behavior.

```{r}
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
for (n in 1:10) { cat(rbinom(1, 1, 0.5)); cat(' ') }
```

Considered as five simulations of ten random variables, $Y_1,
\ldots, Y_{10}$, these simulations would be indexed $y_1^{(1)}, \ldots,
y_{10}^{(1)}$ on the first row up through $y_1^{(5)}, \ldots,
y_{10}^{(5)}$ on the last row.






## More stuff



Random variables can represent unequal odds, such as whether a
roulette ball lands in a red pocket.^[18 out of 38 in a double-zero
wheel.]  They may also represent counts, such as the number of views
of a social media item or the number of points scored by a team in a
competition.  Random variables can also represent continuous
quantities, such as the location from which a shot is taken in a
sporting event or the angle at which a spinner lands after being spun.

Random variables can also be multivariate, such as the result of five
cards drawn from a deck of cards without replacement, or the heights
of the students in next year's introductory statistics class.  They
may also be compound---a sequence of random variables can be used to
represent the distance traveled during the year for each employee of a
company and a random variable can also be used to represent the total
distance traveled by each employee.